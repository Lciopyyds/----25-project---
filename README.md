# 算法设计与分析 project 1 ---- 寻找样本 DNA 序列中的重复片段

[TOC]

## 一、基本信息

1. 姓名：杨一夫
2. 专业：信息安全
3. 学号：23307130124



## 二、问题拆解

这是一个 DNA 比对问题，相当于将两个子串进行比对，删掉相同的部位，然后分析剩余的部分重复点。例如如下的这种模式：

```c
reference:

CTGCAACGTTCGTGGTTCATGTTTGAGCGATAGGCCGAAACTAACCGTGCATGCAACGTTAGTGGATCATTGTGGAACTATAGACTCAAACTAAGCGAGCTTGCAACGTTAGTGGACCCTTTTTGAGCTATAGACGAAAACGGACCGAGGCTGCAAGGTTAGTGGATCATTTTTCAGTTTTAGACACAAACAAACCGAGCCATCAACGTTAGTCGATCATTTTTGTGCTATTGACCATATCTCAGCGAGCCTGCAACGTGAGTGGATCATTCTTGAGCTCTGGACCAAATCTAACCGTGCCAGCAACGCTAGTGGATAATTTTGTTGCTATAGACCAACACTAATCGAGACTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGCCTTACCATCGGACCTCCACGAATCTGAAAAGTTTTAATTTCCGAGCGATACTTACGACCGGACCTCCACGAATCAGAAAGGGTTCACTATCCGCTCGATACATACGATCGGACCTCCACGACTCTGTAAGGTTTCAAAATCCGCACGATAGTTACGACCGTACCTCTACGAATCTATAAGGTTTCAATTTCCGCTGGATCCTTACGATCGGACCTCCTCGAATCTGCAAGGTTTCAATATCCGCTCAATGGTTACGGACGGACCTCCACGCATCTTAAAGGTTAAAATAGGCGCTCGGTACTTACGATCGGACCTCTCCGAATCTCAAAGGTTTCAATATCCGCTTGATACTTACGATCGCAACACCACGGATCTGAAAGGTTTCAATATCCACTCTATA

query:

CTGCAACGTTCGTGGTTCATGTTTGAGCGATAGGCCGAAACTAACCGTGCATGCAACGTTAGTGGATCATTGTGGAACTATAGACTCAAACTAAGCGAGCTTGCAACGTTAGTGGACCCTTTTTGAGCTATAGACGAAAACGGACCGAGGCTGCAAGGTTAGTGGATCATTTTTCAGTTTTAGACACAAACAAACCGAGCCATCAACGTTAGTCGATCATTTTTGTGCTATTGACCATATCTCAGCGAGCCTGCAACGTGAGTGGATCATTCTTGAGCTCTGGACCAAATCTAACCGTGCCAGCAACGCTAGTGGATAATTTTGTTGCTATAGACCAACACTAATCGAGACTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGCCTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGCCTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGCCTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGCCTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGCTAGACCAACACTAATCGAGACTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGCTAGACCAACACTAATCGAGACTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGCTAGACCAACACTAATCGAGACTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGCGCTCGCTTAGCTATGGTCTATGGCGCAAAAATGATGCACTAACGAGGCAGTCTCGATTAGTGTTGGTCTATAGCAACAAAATTATCCACTAGCGTTGCTGGCTCGCTTAGCTATGGTCTATGGCGCAAAAATGATGCACTAACGAGGCAGTCTCGATTAGTGTTGGTCTATAGCAACAAAATTATCCACTAGCGTTGCTGCTTACCATCGGACCTCCACGAATCTGAAAAGTTTTAATTTCCGAGCGATACTTACGACCGGACCTCCACGAATCAGAAAGGGTTCACTATCCGCTCGATACATACGATCGGACCTCCACGACTCTGTAAGGTTTCAAAATCCGCACGATAGTTACGACCGTACCTCTACGAATCTATAAGGTTTCAATTTCCGCTGGATCCTTACGATCGGACCTCCTCGAATCTGCAAGGTTTCAATATCCGCTCAATGGTTACGGACGGACCTCCACGCATCTTAAAGGTTAAAATAGGCGCTCGGTACTTACGATCGGACCTCTCCGAATCTCAAAGGTTTCAATATCCGCTTGATACTTACGATCGCAACACCACGGATCTGAAAGGTTTCAATATCCACTCTATA
```

经过我们人工肉眼匹配（bushi）可以得到如下的情况：

```c
reference:

CTGCAACGTTCGTGGTTCATGTTTGAGCGATAGGCCGAAACTAACCGTGCATGCAACGTTAGTGGATCATTGTGGAACTATAGACTCAAACTAAGCGAGCTTGCAACGTTAGTGGACCCTTTTTGAGCTATAGACGAAAACGGACCGAGGCTGCAAGGTTAGTGGATCATTTTTCAGTTTTAGACACAAACAAACCGAGCCATCAACGTTAGTCGATCATTTTTGTGCTATTGACCATATCTCAGCGAGCCTGCAACGTGAGTGGATCATTCTTGAGCTCTGGACCAAATCTAACCGTGCCAGCAACGCTAGTGGATAATTTTGTTGCTATAGACCAACACTAATCGAGACTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGC

CTTACCATCGGACCTCCACGAATCTGAAAAGTTTTAATTTCCGAGCGATACTTACGACCGGACCTCCACGAATCAGAAAGGGTTCACTATCCGCTCGATACATACGATCGGACCTCCACGACTCTGTAAGGTTTCAAAATCCGCACGATAGTTACGACCGTACCTCTACGAATCTATAAGGTTTCAATTTCCGCTGGATCCTTACGATCGGACCTCCTCGAATCTGCAAGGTTTCAATATCCGCTCAATGGTTACGGACGGACCTCCACGCATCTTAAAGGTTAAAATAGGCGCTCGGTACTTACGATCGGACCTCTCCGAATCTCAAAGGTTTCAATATCCGCTTGATACTTACGATCGCAACACCACGGATCTGAAAGGTTTCAATATCCACTCTATA



query:

CTGCAACGTTCGTGGTTCATGTTTGAGCGATAGGCCGAAACTAACCGTGCATGCAACGTTAGTGGATCATTGTGGAACTATAGACTCAAACTAAGCGAGCTTGCAACGTTAGTGGACCCTTTTTGAGCTATAGACGAAAACGGACCGAGGCTGCAAGGTTAGTGGATCATTTTTCAGTTTTAGACACAAACAAACCGAGCCATCAACGTTAGTCGATCATTTTTGTGCTATTGACCATATCTCAGCGAGCCTGCAACGTGAGTGGATCATTCTTGAGCTCTGGACCAAATCTAACCGTGCCAGCAACGCTAGTGGATAATTTTGTTGCTATAGACCAACACTAATCGAGACTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGC

CTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGC

CTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGC

CTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGC

CTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGC

TAGACCAACACTAATCGAGACTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGC

TAGACCAACACTAATCGAGACTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGC

TAGACCAACACTAATCGAGACTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGC

GCTCGCTTAGCTATGGTCTATGGCGCAAAAATGATGCACTAACGAGGCAGTCTCGATTAGTGTTGGTCTATAGCAACAAAATTATCCACTAGCGTTGCTG

GCTCGCTTAGCTATGGTCTATGGCGCAAAAATGATGCACTAACGAGGCAGTCTCGATTAGTGTTGGTCTATAGCAACAAAATTATCCACTAGCGTTGCTG

CTTACCATCGGACCTCCACGAATCTGAAAAGTTTTAATTTCCGAGCGATACTTACGACCGGACCTCCACGAATCAGAAAGGGTTCACTATCCGCTCGATACATACGATCGGACCTCCACGACTCTGTAAGGTTTCAAAATCCGCACGATAGTTACGACCGTACCTCTACGAATCTATAAGGTTTCAATTTCCGCTGGATCCTTACGATCGGACCTCCTCGAATCTGCAAGGTTTCAATATCCGCTCAATGGTTACGGACGGACCTCCACGCATCTTAAAGGTTAAAATAGGCGCTCGGTACTTACGATCGGACCTCTCCGAATCTCAAAGGTTTCAATATCCGCTTGATACTTACGATCGCAACACCACGGATCTGAAAGGTTTCAATATCCACTCTATA
```

我们可以发现，重复片段的成因，其中：`CTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGC` 是复制的紧跟着的前面的一段，`TAGACCAACACTAATCGAGACTGCCTCGTTAGTGCATCATTTTTGCGCCATAGACCATAGCTAAGCGAGC` 也是直接复制的前面的一段，不过序列长度比先前的一个要长；最后一段序列比较特殊，它是一个倒序互补序列：

`GCTCGCTTAGCTATGGTCTATGGCGCAAAAATGATGCACTAACGAGGCAGTCTCGATTAGTGTTGGTCTATAGCAACAAAATTATCCACTAGCGTTGCTG` 我们人工尝试配对，发现这段是从开始出现重复序列的部分一次向前推的互补序列。

本实验的目的就是找出这些序列的位置和对应的序列长度。



## 三、算法

### 伪代码与算法思路

#### **整体思路**
该算法用于将较短的查询DNA序列比对到较长的参考序列，寻找覆盖查询序列的最少连续匹配片段。核心思路是通过哈希表加速子串匹配，结合动态规划寻找最优分割路径。主要步骤如下：

1. **输入处理与验证**
   读取参考序列和查询序列，去除首尾空格并转换为大写。验证序列是否包含非法字符（仅允许A/T/C/G）。

2. **构建参考哈希表**
   遍历参考序列的正向和反向互补序列，计算所有可能子串的哈希值，存储其位置及方向信息，用于后续快速查找。

3. **动态规划匹配**
   从查询序列末尾向前处理，对每个起始位置，尝试匹配尽可能长的子串。通过哈希表查找是否存在匹配的参考子串，记录最小分割次数及路径。

4. **路径回溯**
   根据动态规划记录的路径信息，从查询序列起始位置开始，逐步提取匹配的参考位置及方向，构建最终比对结果。

---

#### **详细伪代码**

```plaintext
// 输入处理与验证
Function main():
    print("===== DNA Sequence Alignment Tool =====")
  
    ref_seq = read_input("Reference sequence")
    query_seq = read_input("Query sequence")
  
    validate_dna(ref_seq)
    validate_dna(query_seq)
  
    // 构建哈希表
    ref_map = new HashMap()
    build_reference_hash(ref_seq, ref_map, reverse=false)
    build_reference_hash(ref_seq, ref_map, reverse=true)
  
    // 动态规划寻找最优路径
    trace = find_optimal_path(query_seq, ref_map)
  
    // 回溯路径并输出结果
    result = reconstruct_path(trace, query_seq.length)
    print_alignment_result(result)


// 构建参考序列的哈希表
Function build_reference_hash(dna, map, reverse):
    if reverse:
        processed_dna = reverse_complement(dna)  // 生成反向互补序列
    else:
        processed_dna = dna
  
    for start = 0 to dna.length-1:
        hash = 0
        for end = start to dna.length-1:
            char = processed_dna[end]
            hash = (hash * 5 + char_to_num(char)) mod MOD
            if hash not in map:
                if reverse:
                    ref_start = dna.length - end - 1
                    ref_end = dna.length - start - 1
                else:
                    ref_start = start
                    ref_end = end
                map[hash] = RefSeq(ref_start, ref_end, reverse)


// 动态规划匹配查询序列
Function find_optimal_path(query, ref_map):
    n = query.length
    dp = array of size (n+1) filled with INF
    dp[n] = 0  // 末尾无需分割
    trace = array of size (n+1) initialized to null
  
    for start = n-1 downto 0:
        current_hash = 0
        for end = start to n-1:
            current_char = query[end]
            current_hash = (current_hash * 5 + char_to_num(current_char)) mod MOD
            if current_hash in ref_map:
                candidate_cost = dp[end+1] + 1
                if candidate_cost < dp[start] or (candidate_cost == dp[start] and ref_map[current_hash].is_forward):
                    dp[start] = candidate_cost
                    trace[start] = Trace(ref_map[current_hash], end+1, start, end)
    return trace


// 回溯匹配路径
Function reconstruct_path(trace, query_len):
    result = []
    pos = 0
    while pos < query_len:
        if trace[pos] is null:
            throw error("No match found at position pos")
        segment = trace[pos]
        result.add(MatchSegment(segment.ref_seq, segment.query_start, segment.query_end))
        pos = segment.next
    return result


// 辅助函数
Function reverse_complement(dna):
    // 生成反向互补序列（同代码逻辑）

Function char_to_num(c):
    return {'A':1, 'T':2, 'C':3, 'G':4}[c]

Function validate_dna(seq):
    for c in seq:
        if c not in {'A','T','C','G'}:
            throw error("Invalid DNA character")
```

---

#### **关键算法分析**

1. **哈希表构建**
   - **时间复杂度**：O(L²)，L为参考序列长度。遍历所有子串，计算哈希值。
   - **哈希设计**：多项式哈希（基数5，模10^13+7），将子串映射为唯一数值。正向和反向互补序列分别处理，确保双向匹配。

2. **动态规划优化**
   - **状态定义**：`dp[i]`表示从查询位置i到末尾的最小分割次数。
   - **状态转移**：对每个起始位置i，尝试所有可能的结束位置j，若子串i-j存在于参考序列，则更新`dp[i] = min(dp[i], dp[j+1]+1)`。
   - **路径记录**：`trace`数组保存每一步的最优匹配信息，用于回溯。

3. **路径回溯**
   - 从查询序列起始位置开始，根据`trace`记录的下一跳位置，逐步提取匹配片段，直至覆盖整个查询序列。

---

#### **复杂度与优化**
- **时间复杂度**：
  - 哈希构建：O(L²)
  - 动态规划：O(Q²)，Q为查询序列长度
  - 总体复杂度为O(L² + Q²)，适用于L≤1e4，Q≤1e3的规模。
- **空间复杂度**：
  - 哈希表存储O(L²)项，实际中可能因哈希冲突覆盖部分项。

**潜在优化方向**：
1. **限制子串最大长度**：DNA比对中长匹配更常见，可设置最大子串长度（如100bp）。
2. **Rolling Hash优化**：使用双哈希减少冲突概率。
3. **并行计算**：哈希构建和动态规划阶段可并行化。

## 四、实验结果



不过我们发现，在刚开始出现匹配的时候，出现了一点点小问题，重复片段 GCCT 中的 CT 正好和下面的reference 的尾部的 CT 相对应，因此，我们在匹配的时候就会出现这个问题，不过对于整个实验而言无伤大雅。


